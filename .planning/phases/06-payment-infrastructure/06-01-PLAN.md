---
phase: 06-payment-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/00006_token_purchases.sql
  - src/lib/stripe/tiers.ts
  - src/lib/stripe/server.ts
  - src/lib/stripe/client.ts
  - src/middleware.ts
  - package.json
  - .env.local
autonomous: true
requirements: [PAY-03, PAY-04, PAY-05, PAY-06]

must_haves:
  truths:
    - "A row can be inserted into token_purchases with a Stripe PI ID, tier, amount, tokens, and status"
    - "Inserting a duplicate Stripe event ID into stripe_events is rejected by the database"
    - "A token_ledger INSERT with reason 'token_purchase' succeeds without constraint violation"
    - "Calling credit_token_purchase RPC atomically credits tokens and updates purchase status"
    - "Calling credit_token_purchase RPC twice with the same PI ID does not double-credit"
    - "Apple Pay domain verification file is accessible at https://frontrun.bet/.well-known/apple-developer-merchantid-domain-association"
  artifacts:
    - path: "supabase/migrations/00006_token_purchases.sql"
      provides: "token_purchases table, stripe_events table, ledger CHECK migration, credit_token_purchase RPC"
      min_lines: 80
    - path: "src/lib/stripe/tiers.ts"
      provides: "Server-authoritative token pack tier constants"
      exports: ["TIERS", "TierKey"]
    - path: "src/lib/stripe/server.ts"
      provides: "Stripe server SDK singleton"
      exports: ["stripe"]
    - path: "src/lib/stripe/client.ts"
      provides: "Stripe client-side loadStripe singleton"
      exports: ["stripePromise"]
  key_links:
    - from: "supabase/migrations/00006_token_purchases.sql"
      to: "token_ledger"
      via: "ALTER CHECK constraint to add token_purchase reason"
      pattern: "token_purchase"
    - from: "supabase/migrations/00006_token_purchases.sql"
      to: "stripe_events"
      via: "UNIQUE constraint on event_id column"
      pattern: "UNIQUE.*event_id"
    - from: "supabase/migrations/00006_token_purchases.sql"
      to: "token_purchases + token_ledger"
      via: "credit_token_purchase RPC atomically inserts ledger + updates purchase"
      pattern: "credit_token_purchase"
---

<objective>
Set up all database schema, Stripe configuration, Apple Pay domain verification, and atomic fulfillment RPC so that backend and frontend payment code in Phases 7-8 has a complete foundation.

Purpose: Every downstream payment component (webhook handler, create-intent endpoint, buy page) depends on these tables, constraints, and RPC existing. The token_ledger CHECK constraint must be migrated BEFORE any payment code deploys (Pitfall 7). The stripe_events dedup table must exist before any webhooks arrive (Pitfall 1). Apple Pay domain registration can take up to 24h, so registering early avoids blocking Phase 8.

Output: Migration applied to Supabase, Stripe packages installed, tier constants defined, Stripe SDK singletons created, Apple Pay domain registered, env vars configured locally and on Netlify.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/ARCHITECTURE.md
@.planning/research/PITFALLS.md
@.planning/research/STACK.md

@supabase/migrations/00001_initial_schema.sql (existing token_ledger schema, CHECK constraint pattern)
@supabase/migrations/00002_markets_and_betting.sql (existing place_bet RPC pattern)
@src/lib/supabase/admin.ts (existing admin client pattern for server-side Supabase)
@src/middleware.ts (middleware matcher — needs .well-known exclusion and /buy protection)
@package.json (current deps — need to add stripe packages)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Database migration, Stripe packages, tier constants, and SDK singletons</name>
  <files>
    supabase/migrations/00006_token_purchases.sql
    src/lib/stripe/tiers.ts
    src/lib/stripe/server.ts
    src/lib/stripe/client.ts
    package.json
    .env.local
  </files>
  <action>
**1. Create the database migration** at `supabase/migrations/00006_token_purchases.sql`:

**token_purchases table:**
```sql
CREATE TABLE token_purchases (
  id                       UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id                  UUID NOT NULL REFERENCES profiles(id),
  stripe_payment_intent_id TEXT UNIQUE NOT NULL,
  tier                     TEXT NOT NULL CHECK (tier IN ('small', 'medium', 'large')),
  amount_cents             INTEGER NOT NULL,
  tokens_credited          INTEGER NOT NULL,
  status                   TEXT NOT NULL DEFAULT 'pending'
                           CHECK (status IN ('pending', 'completed', 'failed')),
  created_at               TIMESTAMPTZ DEFAULT NOW(),
  completed_at             TIMESTAMPTZ
);
```
- Add indexes: `idx_token_purchases_user` on `user_id`, unique index on `stripe_payment_intent_id`
- Enable RLS. Two policies: (1) users read own purchases `auth.uid() = user_id`, (2) service role manages all via `FOR ALL USING (true) WITH CHECK (true)`

**stripe_events table:**
```sql
CREATE TABLE stripe_events (
  id                UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  event_id          TEXT UNIQUE NOT NULL,
  event_type        TEXT NOT NULL,
  payment_intent_id TEXT,
  processed_at      TIMESTAMPTZ DEFAULT NOW(),
  status            TEXT DEFAULT 'processed'
);
```
- Enable RLS with service-role-only policy (no user reads needed)

**Alter token_ledger CHECK constraint:**
```sql
ALTER TABLE token_ledger DROP CONSTRAINT token_ledger_reason_check;
ALTER TABLE token_ledger ADD CONSTRAINT token_ledger_reason_check
  CHECK (reason IN (
    'signup_bonus', 'bet_placed', 'resolution_payout',
    'market_cancelled_refund', 'adjustment', 'token_purchase'
  ));
```

**credit_token_purchase RPC** — follows the existing `place_bet` RPC pattern:
- `CREATE OR REPLACE FUNCTION credit_token_purchase(p_payment_intent_id TEXT, p_user_id UUID, p_tokens INTEGER) RETURNS JSON`
- `LANGUAGE plpgsql SECURITY DEFINER SET search_path = public`
- SELECT ... FROM token_purchases WHERE stripe_payment_intent_id = p_payment_intent_id FOR UPDATE (row lock)
- If NOT FOUND: return `json_build_object('error', 'Purchase not found')`
- If status = 'completed': return `json_build_object('already_processed', true)` (idempotency)
- If user_id != p_user_id: return `json_build_object('error', 'User mismatch')`
- INSERT INTO token_ledger (user_id, amount, reason, reference_id) VALUES (p_user_id, p_tokens, 'token_purchase', v_purchase.id)
- UPDATE token_purchases SET status = 'completed', completed_at = NOW() WHERE id = v_purchase.id
- Return `json_build_object('success', true, 'ledger_id', v_ledger_id, 'tokens_credited', p_tokens)`

**2. Install Stripe packages:**
```bash
npm install stripe @stripe/stripe-js @stripe/react-stripe-js
```

**3. Create `src/lib/stripe/tiers.ts`:**
- Export `TIERS` object with three tiers:
  - `small`: { price_cents: 500, tokens: 500, label: '$5 — 500 Tokens' }
  - `medium`: { price_cents: 1000, tokens: 1100, label: '$10 — 1,100 Tokens', bonus: '10% bonus' }
  - `large`: { price_cents: 2000, tokens: 2400, label: '$20 — 2,400 Tokens', bonus: '20% bonus' }
- Export `TierKey` type: `'small' | 'medium' | 'large'`
- Export `tierSchema` Zod enum for validation: `z.enum(['small', 'medium', 'large'])`
- Use `as const` for type safety. These are the server-authoritative prices — the client NEVER sends dollar amounts.

**4. Create `src/lib/stripe/server.ts`:**
- Import Stripe from 'stripe'
- Export a singleton: `export const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!)`
- Add a guard: if `!process.env.STRIPE_SECRET_KEY` throw an error with a clear message
- This file is server-only — no `'use client'` directive, no `NEXT_PUBLIC_` env var usage

**5. Create `src/lib/stripe/client.ts`:**
- `'use client'` directive at top
- Import `loadStripe` from `@stripe/stripe-js`
- Export `stripePromise = loadStripe(process.env.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY!)` — call outside component render (module-level) to avoid re-creating the Stripe object on every render

**6. Configure environment variables:**
- Read Stripe keys from `~/templates/.env.master` (look for `STRIPE_SECRET_KEY`, `STRIPE_PUBLISHABLE_KEY`, `STRIPE_WEBHOOK_SECRET` or similar)
- If keys are NOT in .env.master, use the `stripe` CLI to get them: `stripe config --list` or note they need to be obtained from Stripe Dashboard
- Add to `.env.local`:
  ```
  STRIPE_SECRET_KEY=sk_test_...
  STRIPE_WEBHOOK_SECRET=whsec_... (will be set when stripe listen is used in Phase 7)
  NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY=pk_test_...
  ```

**7. Apply the migration:**
```bash
supabase db push
```
Verify the migration applied successfully. If the remote project has different constraints, use `supabase migration up --linked` or apply via the Supabase SQL editor as fallback.

**8. Update CLAUDE.md** to add `token_purchase` to the token ledger reasons list in the Conventions section.
  </action>
  <verify>
- `npm run build` succeeds (no TypeScript errors from new files)
- Migration applied: connect to Supabase and verify:
  - `SELECT * FROM token_purchases LIMIT 0;` succeeds (table exists)
  - `SELECT * FROM stripe_events LIMIT 0;` succeeds (table exists)
  - `INSERT INTO stripe_events (event_id, event_type) VALUES ('evt_test_1', 'test'); INSERT INTO stripe_events (event_id, event_type) VALUES ('evt_test_1', 'test');` — second INSERT fails with UNIQUE violation
  - Verify CHECK constraint: insert a token_ledger row with reason 'token_purchase' via admin client (should succeed)
- `src/lib/stripe/tiers.ts` exports TIERS, TierKey, tierSchema
- `src/lib/stripe/server.ts` exports stripe singleton
- `src/lib/stripe/client.ts` exports stripePromise
  </verify>
  <done>
- token_purchases table exists with all required columns, UNIQUE on stripe_payment_intent_id, RLS enabled
- stripe_events table exists with UNIQUE on event_id
- token_ledger CHECK constraint accepts 'token_purchase' as a valid reason
- credit_token_purchase RPC exists and is callable
- Stripe npm packages installed (stripe, @stripe/stripe-js, @stripe/react-stripe-js in package.json)
- Tier constants defined with server-authoritative pricing ($5/500, $10/1100, $20/2400)
- Stripe server and client singletons created
- Environment variables configured in .env.local
  </done>
</task>

<task type="auto">
  <name>Task 2: Apple Pay domain registration, middleware update, and Netlify env vars</name>
  <files>
    src/middleware.ts
  </files>
  <action>
**1. Register Apple Pay domain in Stripe:**
Use the Stripe CLI to register the domain:
```bash
stripe apple_pay domains create --domain-name frontrun.bet
stripe apple_pay domains create --domain-name www.frontrun.bet
```
If the CLI command is not available or fails, register the domains via the Stripe Dashboard at Settings > Payment Methods > Domains. This must be done in BOTH test mode and live mode.

**2. Update `src/middleware.ts`:**
- Add `/buy` to the `protectedPrefixes` array so it requires authentication:
  ```typescript
  const protectedPrefixes = ['/feed', '/leaderboard', '/profile', '/admin', '/markets', '/buy'];
  ```
- Update the middleware matcher to exclude `.well-known` paths (Apple Pay domain verification):
  ```typescript
  export const config = {
    matcher: [
      '/((?!_next/static|_next/image|favicon.ico|\\.well-known|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)',
    ],
  };
  ```
  Note the `\\.well-known` addition in the negative lookahead. This ensures Stripe/Apple can access the verification file without triggering auth middleware.

**3. Set Stripe environment variables on Netlify:**
Use the Netlify CLI to set the environment variables for the production site:
```bash
netlify env:set STRIPE_SECRET_KEY "sk_test_..." --context production
netlify env:set STRIPE_WEBHOOK_SECRET "whsec_..." --context production
netlify env:set NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY "pk_test_..." --context production
```
Read the actual key values from `~/templates/.env.master` or from the `.env.local` file configured in Task 1. Use test-mode keys for now — live-mode keys are switched in Phase 9 (go-live).

**4. Verify Apple Pay domain:**
After the domain is registered and the site is deployed (or using the current deployment):
```bash
curl -s https://frontrun.bet/.well-known/apple-developer-merchantid-domain-association | head -c 100
```
If this returns content (not a 404 or redirect), domain verification is working. If it fails, Stripe handles the file serving automatically — verify the domain registration status in Stripe Dashboard.

**5. Deploy to trigger Netlify rebuild** with the new env vars (push to main or trigger via `netlify deploy --build --prod` if needed, but prefer pushing to main per project conventions).
  </action>
  <verify>
- `src/middleware.ts` contains `/buy` in protectedPrefixes
- `src/middleware.ts` matcher excludes `.well-known`
- `stripe apple_pay domains list` shows `frontrun.bet` and `www.frontrun.bet` registered
- `curl https://frontrun.bet/.well-known/apple-developer-merchantid-domain-association` returns content (not 404)
- Netlify environment variables set: verify with `netlify env:list` showing STRIPE_SECRET_KEY, STRIPE_WEBHOOK_SECRET, NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY
- `npm run build` succeeds with middleware changes
  </verify>
  <done>
- Apple Pay domains (frontrun.bet and www.frontrun.bet) registered in Stripe for domain verification
- Middleware updated: /buy is auth-protected, .well-known paths are excluded from middleware matching
- Stripe environment variables set on Netlify production context
- Apple Pay verification file accessible at the well-known URL
  </done>
</task>

</tasks>

<verification>
Run these checks after both tasks complete:

1. **Database schema verification:**
   ```sql
   -- Via Supabase SQL editor or supabase db query:
   SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name IN ('token_purchases', 'stripe_events');
   -- Should return 2 rows

   -- Test idempotency of credit_token_purchase:
   -- 1. Insert a pending purchase
   -- 2. Call credit_token_purchase — should succeed
   -- 3. Call credit_token_purchase again with same PI — should return already_processed
   ```

2. **Build verification:** `npm run build` passes with no errors

3. **Apple Pay domain:** `curl https://frontrun.bet/.well-known/apple-developer-merchantid-domain-association` returns verification file content

4. **Stripe packages:** `npm ls stripe @stripe/stripe-js @stripe/react-stripe-js` shows all three installed

5. **Environment:** `.env.local` has STRIPE_SECRET_KEY, STRIPE_WEBHOOK_SECRET, NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY
</verification>

<success_criteria>
- token_purchases table exists with UNIQUE constraint on stripe_payment_intent_id — inserting a duplicate PI ID is rejected
- stripe_events table exists with UNIQUE constraint on event_id — inserting a duplicate event ID is rejected
- token_ledger CHECK constraint accepts 'token_purchase' — an INSERT with that reason succeeds
- credit_token_purchase RPC atomically credits tokens and is idempotent — calling twice with same PI does not double-credit
- Apple Pay domain verification file accessible at https://frontrun.bet/.well-known/apple-developer-merchantid-domain-association
- Stripe packages installed, tier constants defined, SDK singletons created
- Middleware protects /buy route and excludes .well-known from matching
</success_criteria>

<output>
After completion, create `.planning/phases/06-payment-infrastructure/06-01-SUMMARY.md`
</output>
