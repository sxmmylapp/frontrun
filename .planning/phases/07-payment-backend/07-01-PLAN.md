---
phase: 07-payment-backend
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/api/payments/create-intent/route.ts
  - src/app/api/webhooks/stripe/route.ts
  - src/types/db.ts
autonomous: true
requirements: [PAY-01, PAY-02]

must_haves:
  truths:
    - "POST /api/payments/create-intent with a valid tier and authenticated session returns a JSON body containing clientSecret"
    - "POST /api/payments/create-intent with an invalid tier returns 400"
    - "POST /api/payments/create-intent without authentication returns 401"
    - "The server determines the dollar amount from the tier constant — the client never sends a price"
    - "POST /api/webhooks/stripe with a valid Stripe signature and payment_intent.succeeded event credits tokens via credit_token_purchase RPC"
    - "POST /api/webhooks/stripe with an invalid signature returns 400"
    - "Sending the same webhook event_id twice does not double-credit tokens — the second call returns 200 but skips fulfillment"
    - "The webhook handler inserts a row into stripe_events with the event_id for deduplication"
    - "The webhook handler reads user_id, tier, and tokens from PaymentIntent metadata"
  artifacts:
    - path: "src/app/api/payments/create-intent/route.ts"
      provides: "PaymentIntent creation endpoint with server-enforced pricing"
      exports: ["POST"]
    - path: "src/app/api/webhooks/stripe/route.ts"
      provides: "Stripe webhook handler with signature verification and idempotent fulfillment"
      exports: ["POST"]
  key_links:
    - from: "src/app/api/payments/create-intent/route.ts"
      to: "src/lib/stripe/tiers.ts"
      via: "Import TIERS for server-authoritative pricing lookup"
      pattern: "TIERS\\[.*\\]\\.price_cents"
    - from: "src/app/api/payments/create-intent/route.ts"
      to: "src/lib/stripe/server.ts"
      via: "Import stripe singleton for PaymentIntent creation"
      pattern: "stripe\\.paymentIntents\\.create"
    - from: "src/app/api/webhooks/stripe/route.ts"
      to: "supabase/migrations/00006_token_purchases.sql"
      via: "Calls credit_token_purchase RPC for atomic token crediting"
      pattern: "credit_token_purchase"
    - from: "src/app/api/webhooks/stripe/route.ts"
      to: "src/lib/stripe/server.ts"
      via: "Import stripe singleton for webhook signature verification"
      pattern: "stripe\\.webhooks\\.constructEvent"
---

<objective>
Create the two server-side API route handlers that form the payment backend: (1) a create-intent endpoint that creates Stripe PaymentIntents with server-enforced pricing, and (2) a webhook handler that verifies Stripe signatures and idempotently credits tokens via the credit_token_purchase RPC.

Purpose: The buy page (Phase 8) needs an endpoint to call when the user confirms a payment, and Stripe needs a webhook endpoint to notify us when payment succeeds. Both must be working and verified before any frontend payment code is built.

Output: Two route handlers deployed and verified with the Stripe CLI — a test payment round-trip completes end-to-end (PaymentIntent created, webhook received, tokens credited, purchase marked completed).
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/ARCHITECTURE.md
@.planning/research/PITFALLS.md

@src/lib/stripe/tiers.ts (tier constants — import TIERS and tierSchema)
@src/lib/stripe/server.ts (Stripe server singleton — import stripe)
@src/lib/stripe/client.ts (client loadStripe — NOT used in this phase)
@src/lib/supabase/server.ts (createClient for cookie-based auth)
@src/lib/supabase/admin.ts (createAdminClient for service role operations)
@supabase/migrations/00006_token_purchases.sql (token_purchases table, stripe_events table, credit_token_purchase RPC)
@src/middleware.ts (middleware excludes .well-known, protects /buy — no changes needed)
@package.json (stripe packages already installed)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Regenerate Supabase types and create PaymentIntent endpoint</name>
  <files>
    src/types/db.ts
    src/app/api/payments/create-intent/route.ts
  </files>
  <action>
**1. Regenerate Supabase TypeScript types** to include the new tables from migration 00006:
```bash
supabase gen types --lang=typescript --project-id ciggxvzbwwnhvyjjipzn > src/types/db.ts
```
This ensures TypeScript knows about `token_purchases`, `stripe_events`, and the `credit_token_purchase` RPC.

**2. Create the PaymentIntent creation endpoint** at `src/app/api/payments/create-intent/route.ts`:

**Authentication:** Use `createClient()` from `@/lib/supabase/server` to get the authenticated user from cookies. If no user, return 401.

**Validation:** Parse the request body with `tierSchema` from `@/lib/stripe/tiers`. If invalid, return 400 with error message.

**PaymentIntent creation:**
- Import `stripe` from `@/lib/stripe/server`
- Import `TIERS` from `@/lib/stripe/tiers`
- Look up tier: `const tier = TIERS[parsed.data]` — server determines the price
- Create PaymentIntent:
  ```typescript
  const paymentIntent = await stripe.paymentIntents.create({
    amount: tier.price_cents,
    currency: 'usd',
    automatic_payment_methods: { enabled: true },
    metadata: {
      user_id: user.id,
      tier: parsed.data,
      tokens: tier.tokens.toString(),
    },
  });
  ```
- The metadata is critical — the webhook handler reads `user_id`, `tier`, and `tokens` from it

**Record pending purchase:**
- Use `createAdminClient()` to bypass RLS
- Insert into `token_purchases`:
  ```typescript
  await admin.from('token_purchases').insert({
    user_id: user.id,
    stripe_payment_intent_id: paymentIntent.id,
    tier: parsed.data,
    amount_cents: tier.price_cents,
    tokens_credited: tier.tokens,
    status: 'pending',
  });
  ```

**Return:** `{ clientSecret: paymentIntent.client_secret }`

**Logging:** Use structured logging: `[ISO timestamp] INFO/ERROR: create-intent [details]`

**Error handling:** Wrap the Stripe call in try/catch. On Stripe error, return 500 with generic message (don't leak Stripe error details to client).
  </action>
  <verify>
- `npm run build` succeeds (no TypeScript errors)
- The route file exists at `src/app/api/payments/create-intent/route.ts`
- The route imports `stripe` from `@/lib/stripe/server` (not creating a new Stripe instance)
- The route imports `TIERS` and `tierSchema` from `@/lib/stripe/tiers` (server-authoritative pricing)
- The route uses `createClient()` for auth and `createAdminClient()` for DB writes
  </verify>
  <done>
- Supabase types regenerated with token_purchases, stripe_events, credit_token_purchase
- POST /api/payments/create-intent route handler created with:
  - Cookie-based authentication via Supabase server client
  - Zod tier validation via tierSchema
  - Server-determined pricing from TIERS constant (client never sends amount)
  - PaymentIntent created with user_id, tier, tokens in metadata
  - Pending purchase record inserted into token_purchases
  - Structured error handling and logging
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Stripe webhook handler with signature verification and idempotent fulfillment</name>
  <files>
    src/app/api/webhooks/stripe/route.ts
  </files>
  <action>
**Create the webhook handler** at `src/app/api/webhooks/stripe/route.ts`:

**CRITICAL: Raw body for signature verification (Pitfall 2):**
```typescript
const body = await request.text(); // MUST be text(), NOT json()
const signature = request.headers.get('stripe-signature')!;
```
Using `request.json()` would break signature verification because re-stringifying produces different bytes.

**Signature verification:**
```typescript
import { stripe } from '@/lib/stripe/server';

let event: Stripe.Event;
try {
  event = stripe.webhooks.constructEvent(
    body,
    signature,
    process.env.STRIPE_WEBHOOK_SECRET!
  );
} catch (err) {
  console.error(`[${ts}] ERROR: webhook signature verification failed`, err);
  return NextResponse.json({ error: 'Invalid signature' }, { status: 400 });
}
```

**Event routing:**
- Handle `payment_intent.succeeded` — credit tokens
- Handle `payment_intent.payment_failed` — mark purchase as failed (Pitfall 12)
- Return 200 for all other event types (don't block Stripe retries)

**For `payment_intent.succeeded`:**

1. **Deduplication (Pitfall 1):** Insert into `stripe_events` table. If the insert fails with a unique violation on `event_id`, return 200 immediately (already processed).
   ```typescript
   const admin = createAdminClient();
   const { error: dedupError } = await admin.from('stripe_events').insert({
     event_id: event.id,
     event_type: event.type,
     payment_intent_id: paymentIntent.id,
   });
   if (dedupError?.code === '23505') {
     // Unique violation — already processed
     console.info(`[${ts}] INFO: webhook duplicate event ${event.id}, skipping`);
     return NextResponse.json({ received: true });
   }
   ```

2. **Extract metadata:**
   ```typescript
   const paymentIntent = event.data.object as Stripe.PaymentIntent;
   const userId = paymentIntent.metadata.user_id;
   const tokens = parseInt(paymentIntent.metadata.tokens, 10);
   ```

3. **Credit tokens via atomic RPC:**
   ```typescript
   const { data, error } = await admin.rpc('credit_token_purchase', {
     p_payment_intent_id: paymentIntent.id,
     p_user_id: userId,
     p_tokens: tokens,
   });
   ```
   The RPC handles its own idempotency (checks purchase status = 'completed'), but the stripe_events dedup is the primary defense.

4. **Log outcome:** Log success or error with payment intent ID, user ID, and token count.

**For `payment_intent.payment_failed`:**
- Update `token_purchases` row to `status = 'failed'` where `stripe_payment_intent_id` matches
- Log the failure reason

**Performance (Pitfall 4):** Keep handler lean. No heavy queries. The RPC does the heavy lifting in a single DB round-trip. Target < 5 seconds total execution for Netlify's 10-second serverless limit.

**Important: Do NOT add authentication middleware to this route.** The webhook is called by Stripe, not by authenticated users. The Stripe signature is the authentication mechanism.
  </action>
  <verify>
- `npm run build` succeeds
- The route file exists at `src/app/api/webhooks/stripe/route.ts`
- The route uses `request.text()` for the body (NOT `request.json()`)
- The route calls `stripe.webhooks.constructEvent()` for signature verification
- The route inserts into `stripe_events` for deduplication before crediting
- The route calls `credit_token_purchase` RPC for atomic token crediting
- The route handles both `payment_intent.succeeded` and `payment_intent.payment_failed`
- The route returns 200 for unhandled event types
  </verify>
  <done>
- POST /api/webhooks/stripe route handler created with:
  - Raw body parsing via request.text() for correct signature verification
  - Stripe webhook signature verification via constructEvent
  - Deduplication via stripe_events table insert (UNIQUE on event_id)
  - Token crediting via credit_token_purchase atomic RPC
  - payment_intent.payment_failed handling (marks purchase as failed)
  - Structured logging for all outcomes
  - Returns 200 for unhandled event types
  </done>
</task>

<task type="auto">
  <name>Task 3: End-to-end verification with Stripe CLI</name>
  <files>
  </files>
  <action>
**Verify the full round-trip using the Stripe CLI:**

**1. Start the dev server:**
```bash
npm run dev &
# Wait for it to be ready
```

**2. Start Stripe webhook forwarding:**
```bash
stripe listen --forward-to http://localhost:3000/api/webhooks/stripe 2>&1
```
Copy the webhook signing secret from the output (starts with `whsec_`). Update `.env.local` with this secret as `STRIPE_WEBHOOK_SECRET`. Restart the dev server to pick up the new secret.

**3. Test the create-intent endpoint:**
Use curl to call the endpoint. Since it requires authentication (Supabase cookies), test by:
- Checking that the route returns 401 for unauthenticated requests:
  ```bash
  curl -s -X POST http://localhost:3000/api/payments/create-intent \
    -H "Content-Type: application/json" \
    -d '{"tier":"small"}' | jq .
  ```
  Expected: `{ "error": "Not authenticated" }` with 401 status

- Checking that invalid tier returns 400:
  ```bash
  curl -s -X POST http://localhost:3000/api/payments/create-intent \
    -H "Content-Type: application/json" \
    -d '{"tier":"invalid"}' | jq .
  ```
  Expected: `{ "error": "Invalid tier" }` with 400 status

**4. Test the webhook handler with Stripe CLI trigger:**
```bash
stripe trigger payment_intent.succeeded
```
Check the dev server logs — the webhook should:
- Verify the signature successfully
- Insert into stripe_events
- Call credit_token_purchase RPC (will return 'Purchase not found' since there's no matching pending purchase — this is expected for CLI-triggered test events)

**5. Verify webhook signature rejection:**
```bash
curl -s -X POST http://localhost:3000/api/webhooks/stripe \
  -H "Content-Type: application/json" \
  -H "stripe-signature: invalid" \
  -d '{"type":"test"}' | jq .
```
Expected: `{ "error": "Invalid signature" }` with 400 status

**6. Clean up:**
Kill the dev server and stripe listen processes.

**7. Final build verification:**
```bash
npm run build
```
Must succeed with no errors.

**Note:** A full end-to-end test (create-intent -> webhook -> tokens credited) requires an authenticated browser session to call create-intent. This will be tested in Phase 8 when the buy page provides the UI for the flow. The key verification here is that both endpoints work individually and the webhook correctly calls the RPC.
  </action>
  <verify>
- curl to /api/payments/create-intent without auth returns 401
- curl to /api/webhooks/stripe with invalid signature returns 400
- `stripe trigger payment_intent.succeeded` is received by the webhook handler (visible in dev server logs)
- `npm run build` passes with no errors
  </verify>
  <done>
- Unauthenticated requests to create-intent correctly return 401
- Invalid tier requests correctly return 400
- Invalid webhook signatures correctly return 400
- Stripe CLI webhook forwarding works — events are received and processed
- Full build passes with no errors
  </done>
</task>

</tasks>

<verification>
Run these checks after all tasks complete:

1. **Build verification:** `npm run build` passes with no errors

2. **Route existence:**
   - `src/app/api/payments/create-intent/route.ts` exists and exports POST
   - `src/app/api/webhooks/stripe/route.ts` exists and exports POST

3. **Security checks:**
   - create-intent uses `createClient()` for authentication (cookie-based)
   - create-intent imports TIERS from `@/lib/stripe/tiers` (server-authoritative pricing)
   - webhook uses `request.text()` not `request.json()` for body
   - webhook calls `stripe.webhooks.constructEvent()` for signature verification
   - webhook inserts into `stripe_events` before crediting (deduplication)

4. **Endpoint behavior:**
   - POST /api/payments/create-intent without auth -> 401
   - POST /api/payments/create-intent with invalid tier -> 400
   - POST /api/webhooks/stripe with invalid signature -> 400
   - POST /api/webhooks/stripe with valid signature -> processes event and returns 200

5. **Integration:**
   - Webhook calls `credit_token_purchase` RPC (from Phase 6 migration)
   - PaymentIntent metadata includes user_id, tier, tokens
</verification>

<success_criteria>
- POST /api/payments/create-intent creates a PaymentIntent with server-determined pricing and returns clientSecret
- The client never sends a dollar amount — only a tier key
- POST /api/webhooks/stripe verifies Stripe signature using raw body (request.text())
- Webhook deduplicates via stripe_events table before crediting
- Webhook credits tokens via credit_token_purchase atomic RPC
- Sending the same event twice does not double-credit tokens
- Both endpoints handle errors gracefully with structured logging
- npm run build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/07-payment-backend/07-01-SUMMARY.md`
</output>
